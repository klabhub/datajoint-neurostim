function [x,y,a] = eyeTracker(data,pv)
% Pass a ScanBox _eye.mat file name or the data uint8 array from such afile
% to determine pupil center (x,y) and area using imfindcircles.
%
% data -  Either a Filename for *_eye.mat file generated by Scanbox or the
%           uint8 array with camera images from such a file
% Optional PV Pairs
% map - Use this colormap to show the movie
% movie - Show a movie with the detected pupil location and size
% minRadius,maxRadius - Possible sizes  (in pixels) of the pupil [12,32]
% searchRadius - Search only this radius (pixels) around the center of the image [100]
% Options passed to imfindcircles:
% method - PhaseCode or TwoStage ["PhaseCode"]
% sensitivity  - [0.85]
% edgeThreshold - []
%
% Adapted from Dario Ringach' example code
% BK - 3/9/2023
arguments
    data
    pv.nrWorkers = 0
    pv.map = bone
    pv.movie (1,1) logical = false
    pv.minRadius (1,1) double = 12
    pv.maxRadius (1,1) double = 32
    pv.searchRadius  (1,1) double = 90
    % PV pairs passed to imfindcircles
    pv.method = "PhaseCode"
    pv.sensitivity  = 0.85;
    pv.edgeThreshold = [];
end

%TODO Sync with scanner using abstime struct in the file
% Scanner and Eye camera triggers are close but not identical

if isempty(data)
    % Load from file
    load(file)
end


data = squeeze(data); % Squeeze out the 3rd singleton dimension
[nrY,nrX,nrFrames] =size(data);


x = nan(nrFrames,1);
y = nan(nrFrames,1);
a = nan(nrFrames,1);

xWindow  = round(-pv.searchRadius:pv.searchRadius + nrX/2);
yWindow  = round(-pv.searchRadius:pv.searchRadius + nrY/2);
xWindow(xWindow< 1 | xWindow>nrX) =[];
yWindow(yWindow< 1 | yWindow>nrY) =[];
parfor (f=1:nrFrames,pv.nrWorkers)
    zoomed = data(yWindow,xWindow,f);
    [center,radius,metric] = imfindcircles(zoomed,[pv.minRadius pv.maxRadius],'Method',pv.method,'Sensitivity',pv.sensitivity,'EdgeThreshold',pv.edgeThreshold); %#ok<PFBNS>
    if ~isempty(center)
        [~,idx] = max(metric); % pick the circle with best score
        x(f) = center(idx,1);
        y(f) = center(idx,2);
        a(f) = pi*radius(idx)^2;
    end
end


if pv.movie
    % Show it
    hFig = figure(1);
    set(hFig,'Units','Pixels','Position',[100 100 nrX nrY])
    axes('Position',[0 0 1 1])
    colormap(pv.map)
    axis off
    for f=1:nrFrames
        cla
        imshow(data(:,:,f));
        hold on
        if ~isnan(x(f))
            plot(x(f),y(f),'ro','MarkerSize',sqrt(a(f)));
        end
        drawnow
    end
end


end
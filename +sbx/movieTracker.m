function [x,y,a] = movieTracker(in,pv)
% Function extract tracking information from movies recorded by ScanBox cameras.
% Currently this can process _eye and _ball movies. 
% For _eye it estimates eye position and pupil size
% For _ball it estimates 2D velocity.
% 
% in  -  Three options:
%           Filename for a movie file generated by Scanbox 
%           struct (.data, .abstime) with contentfrom such a file, 
%           a ns.Experiment table row.
%
% Optional PV Pairs
% map - Use this colormap to show the movie
% movie - Show a movie with the detected pupil location and size
% minRadius,maxRadius - Possible sizes  (in pixels) of the pupil [12,32]
% searchRadius - Search only this radius (pixels) around the center of the image [100]
% Options passed to imfindcircles:
% method - PhaseCode or TwoStage ["PhaseCode"]
% sensitivity  - [0.85]
% edgeThreshold - []
%
% Adapted from Dario Ringach' example code
% BK - 3/9/2023
arguments
    in
    pv.type char {mustBeMember(pv.type,{'eye','ball'})} = 'eye'
    pv.nrWorkers = 0
    pv.map = bone
    pv.movie (1,1) logical = false
    pv.track (1,1) logical = true

    % Eye movies: PV pairs passed to imfindcircles
    pv.method = "PhaseCode"
    pv.sensitivity  = 0.85;
    pv.edgeThreshold = [];
    pv.minRadius (1,1) double = 10
    pv.maxRadius (1,1) double = 50
    pv.searchRadius  (1,1) double = 90   % From center.


    pv.manualRoi (1,1) logical = false
end

if pv.nrWorkers ==-1
    if isempty(gcp('nocreate'))
        pv.nrWorkers = 0;
    else
        pv.nrWorkers  = gcp('nocreate').NumWorkers;
    end
end

switch class(in)
    case 'ns.Experiment'
        % A key representing an experiment
        matFile = fetch1(ns.File & in & 'extension=''.mat''' & ['filename LIKE ''%_'  pv.type '.mat'''],'filename');
        ff = fullfile(folder(in),matFile);
        movie = load(ff,'data','abstime');
    case 'struct'
        % The data in the _eye or _ball.mat file packaged as a struct
        % with fields .data and .abstime
        movie = in;
    case {'char','string'}
        % Load from file
        load(file,'movie')
    otherwise
        error('sbx.eyeTracker cannot handle %s inputs',class(in));
end



frames = squeeze(movie.data); % Squeeze out the 3rd singleton dimension
[nrY,nrX,nrFrames] =size(frames);
% Scale
frames = single(frames);
frames = (frames-min(frames,[],"all"))./(max(frames,[],"all")-min(frames,[],"all"));


if pv.track
    switch pv.type
        case 'eye'
            x = nan(nrFrames,1);
            y = nan(nrFrames,1);
            a = nan(nrFrames,1);

            if pv.manualRoi
                hPreview= figure;
                colormap(hsv)
                imagesc(frames(:,:,1));


                [xLim,yLim] = ginput(4);
                xWindow = round(min(xLim):max(xLim));
                yWindow = round(min(yLim):max(yLim));
                maxRadius = round(max(yWindow)/2);


                %                 [xLow,yLow] = ginput(5);
                %                 ixLow = sub2ind([nrY nrX],round(yLow),round(xLow));
                %
                %                 [xHi,yHi] = ginput(5);
                %                 ixHi = sub2ind([nrY nrX],round(yHi),round(xHi));
                %                 high = mean(frames(ixHi))
                %                 frames(frames>high) = 0;
                %

                close(hPreview)
            else
                xWindow  = round((-pv.searchRadius:pv.searchRadius) + nrX/2);
                yWindow  = round((-pv.searchRadius:pv.searchRadius) + nrY/2);
                maxRadius= pv.maxRadius;
            end
            xWindow(xWindow< 1 | xWindow>nrX) =[];
            yWindow(yWindow< 1 | yWindow>nrY) =[];

            zoomed = frames(yWindow,xWindow,:);
            %  iCntr=0;
            %             level = nan(100,1);
            %             for i=randperm(nrFrames,100)
            %                 iCntr = iCntr+1;
            %                 level(iCntr) = graythresh(zoomed(:,:,i));
            %             end
            %             %zoomed= imbinarize(zoomed,median(level));

            fprintf('Eye tracking analysis on %d workers\n',pv.nrWorkers)
            %parfor (f=1:nrFrames,pv.nrWorkers)
            for f=1:nrFrames  % debug

                [center,radius,metric] = imfindcircles(zoomed(:,:,f),[pv.minRadius maxRadius],'Method',pv.method,'Sensitivity',pv.sensitivity,'EdgeThreshold',pv.edgeThreshold); %#ok<PFBNS>
                if ~isempty(center)
                    [~,idx] = max(metric); % pick the circle with best score
                    x(f) = xWindow(1) + center(idx,1);
                    y(f) = yWindow(1) + center(idx,2);
                    a(f) = pi*radius(idx)^2;
                end
            end
        case 'ball'
            % Determine successive image shifts by maximizing the
            % cross correlation. 

            iCntr=0;
            level = nan(100,1);
            for i=randperm(nrFrames,100)
                iCntr = iCntr+1;
                level(iCntr) = graythresh(frames(:,:,i));
            end
            frames= imbinarize(frames,median(level));

            velocity = nan(nrFrames,1); 
            quality  = nan(nrFrames,1); 
            parfor f=2:nrFrames
                z1 = frames(:,:,f);
                z2 = frames(:,:,f-1);
                z1 = z1 -mean(z1,"all");
                z2 = z2 -mean(z2,"all");                
                xc =xcorr2(z1,z2);
                [quality(f),ix] = max(xc(:));
                [dy,dx]= ind2sub(size(xc),ix);
                dy = dy-size(z2,1);
                dx = dx-size(z2,2);
                velocity(f) = dx  + 1i.*dy;
            end           
    end
end

if pv.movie
    % Show it
    hFig = figure(1);
    set(hFig,'Units','Pixels','Position',[100 100 2*nrX 2*nrY])
    ax = axes('Position',[0 0 1 1]);
    colormap(ax,pv.map)
    axis(ax,'off')
    if pv.track
        switch (pv.type)
            case 'eye'
                hPupil = plot(ax,0,0,'ro','MarkerSize',1);                
            case 'ball'
                pos = get(ax,'Position');
                axTrack = polaraxes('Position',[0 0 pos(3:4)/5]);
                hArrow = polarplot(axTrack,[0;0],'r');
                axTrack.RTick = [];
                axTrack.RTickLabel = [];
                axTrack.ThetaTick  = [];
                axTrack.ThetaTickLabel  = [];
                axTrack.RLim = [0 prctile(abs(velocity),90)];
        end

        for f=1:nrFrames
            imagesc(ax,movie.data(:,:,f));
       
            if  pv.track
                switch (pv.type)
                    case 'eye'
                        if ~isnan(x(f))                            
                            hPupil.XData = x(f);
                            hPupil.YData = y(f);
                            hPupil.MarkerSize = sqrt(a(f));
                        end
                    case 'ball'
                        if ~isnan(velocity(f))
                            fToKeep = f-25:f;
                            fToKeep(fToKeep<1) =[];
                            nrF =numel(fToKeep);
                            h = polarplot(axTrack,[complex(zeros(1,nrF)) ;velocity(fToKeep)']);
                            ix = round(linspace(255,1,nrF));
                            colors = gray;
                            colors = num2cell(colors(ix,:),2)';
                            [h.Color] =deal(colors{:});
                              axTrack.RTick = [];
                axTrack.RTickLabel = [];
                axTrack.ThetaTick  = [];
                axTrack.ThetaTickLabel  = [];
%                             hArrow.RData = [abs(velocity(fToKeep))];
%                             hArrow.ThetaData = [angle(velocity(fToKeep))];
                        end
                        pause(0.05)
                end
            end

            drawnow
        end
    end


end
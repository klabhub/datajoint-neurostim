function [tracked] = movieTracker(in,pv)
% Function extract tracking information from movies recorded by ScanBox cameras.
% Currently this can process _eye and _ball movies.
% For _eye it estimates eye position and pupil size
% For _ball it estimates 2D velocity.
%
% in  -  Three options:
%           Filename for a movie file generated by Scanbox
%           struct (.data, .abstime) with contentfrom such a file,
%           a ns.Experiment table row.
%
% Optional PV Pairs
% map - Use this colormap to show the movie
% movie - Show a movie with the detected pupil location and size
% minRadius,maxRadius - Possible sizes  (in pixels) of the pupil [12,32]
% searchRadius - Search only this radius (pixels) around the center of the image [100]
% Options passed to imfindcircles:
% method - PhaseCode or TwoStage ["PhaseCode"]
% sensitivity  - [0.85]
% edgeThreshold - []
%
% OUTPUT
% tracked - A struct
%           .x .y .a and .quality for eye tracking
%           .velocity .quality (correlation between successive frames) for ball tracking
%            Each entry corresponds to a sbx frame recorded during this
%            ns.Experiment,
% Adapted from Dario Ringach' example code
% BK - 3/9/2023
arguments
    in
    pv.type char {mustBeMember(pv.type,{'eye','ball'})} = 'eye'
    pv.nrWorkers = -1
    pv.map = bone
    pv.movie (1,1) logical = false
    pv.track (1,1) logical = true

    % Eye movies: PV pairs passed to imfindcircles
    pv.method = "PhaseCode"
    pv.sensitivity  = 0.85;
    pv.edgeThreshold = [];
    pv.minRadius (1,1) double = 10
    pv.maxRadius (1,1) double = 50
    pv.searchRadius  (1,1) double = 90   % From center.


    pv.manualRoi (1,1) logical = false
    pv.binarize (1,1) logical = false
end

%% Get the frames
switch class(in)
    case 'ns.Experiment'
        % A key representing an experiment
        matFile = fetch1(ns.File & in & 'extension=''.mat''' & ['filename LIKE ''%_'  pv.type '.mat'''],'filename');
        ff = fullfile(folder(in),matFile);
        movie = load(ff,'data','abstime');
    case 'struct'
        % The data in the _eye or _ball.mat file packaged as a struct
        % with fields .data and .abstime
        movie = in;
    case {'char','string'}
        % Load from file
        load(file,'movie')
    otherwise
        error('sbx.eyeTracker cannot handle %s inputs',class(in));
end

%% Start parpool if requested
if pv.nrWorkers ==-1
    if isempty(gcp('nocreate'))
        pv.nrWorkers = 0;
    else
        pv.nrWorkers  = gcp('nocreate').NumWorkers;
    end
end

%% Open a figure if requested
if pv.manualRoi || pv.movie
    hFig= findobj(0,'type','figure','name','movieTracker');
    if isempty(hFig)
        hFig =  figure('name','movieTracker');
    end
end


frames = squeeze(movie.data); % Squeeze out the 3rd singleton dimension
[nrY,nrX,nrFrames] =size(frames);
% Scale
frames = single(frames);
frames = (frames-min(frames,[],"all"))./(max(frames,[],"all")-min(frames,[],"all"));

%% Select an ROI manually or based on the search radius
if pv.manualRoi
    figure(hFig)
    colormap("gray")
    imagesc(mean(frames,3,"omitnan"));
        [xLim,yLim] = ginput(2);
        center = [xLim(1) yLim(1)];
        searchRadius = ceil(sqrt(diff(xLim).^2+diff(yLim).^2));
        pv.maxRadius = min(pv.maxRadius,searchRadius);
    range = (-searchRadius:searchRadius);
    xWindow = round(center(1)+range);
    yWindow = round(center(2)+range);
else
    xWindow  = round((-pv.searchRadius:pv.searchRadius) + nrX/2);
    yWindow  = round((-pv.searchRadius:pv.searchRadius) + nrY/2);
end

xWindow(xWindow< 1 | xWindow>nrX) =[];
yWindow(yWindow< 1 | yWindow>nrY) =[];
zoomed = frames(yWindow,xWindow,:);


%% Initialize output vars
quality = nan(nrFrames,1);
x       = nan(nrFrames,1);
y       = nan(nrFrames,1);
a       = nan(nrFrames,1);
velocity = nan(nrFrames,1);
quality  = nan(nrFrames,1);


if pv.binarize
    % Binarize the images based on a threshold estimated from
    % a random sample of 100 frames.
    % Does not seem to help.
    iCntr=0;
    level = nan(100,1);
    for i=randperm(nrFrames,100)
        iCntr = iCntr+1;
        level(iCntr) = graythresh(zoomed(:,:,i));
    end
    zoomed= imbinarize(zoomed,median(level));
end

%% Run the tracking algorithm
if pv.track
    switch pv.type
        case 'eye'
            fprintf('Eye tracking analysis on %d workers\n',pv.nrWorkers)
            %parfor (f=1:nrFrames,pv.nrWorkers)
            for f=1:nrFrames  % debug
                [center,radius,thisQuality] = imfindcircles(zoomed(:,:,f),[pv.minRadius searchRadius],'Method',pv.method,'Sensitivity',pv.sensitivity,'EdgeThreshold',pv.edgeThreshold); %#ok<PFBNS>
                if ~isempty(center)
                    [~,idx] = max(thisQuality); % pick the circle with best score
                    x(f) = xWindow(1) + center(idx,1);
                    y(f) = yWindow(1) + center(idx,2);
                    a(f) = pi*radius(idx)^2;
                end
            end
        case 'ball'
            % Determine successive image shifts by maximizing the
            % cross correlation.

            % Although this could use a parfor, that does not provide much
            % of an advantage (if any). Probably because xcorr already uses
            % multithreading. I also tried imregtform and normxcorr2 but
            % saw worse performance.
            for f=2:nrFrames
                z1 = zoomed(:,:,f);
                z2 = zoomed(:,:,f-1);
                z1 = z1 -mean(z1,"all");
                z2 = z2 -mean(z2,"all");
                xc =xcorr2(z1,z2);
                [maxXC,ix] = max(xc(:));
                quality(f) = maxXC./max(xcorr2((z2+z1)/2,(z2+z1)/2),[],"all");
                [dy,dx]= ind2sub(size(xc),ix);
                dy = dy-size(z2,1);
                dx = dx-size(z2,2);
                velocity(f) = dx  + 1i.*dy;
            end
    end
end

%% Show a movie
if pv.movie
    % Show it
    figure(hFig);
    ax = axes('Position',[0 0 1 1]);
    colormap(ax,pv.map)
    axis(ax,'off')

    if pv.track
        switch (pv.type)
            case 'eye'
            case 'ball'
                % Show the tracked velocity in the lower left corner
                pos = get(ax,'Position');
                axTrack = polaraxes('Position',[0 0 pos(3:4)/5]);
                % Outliers will point out of the circle.
                axTrack.RLim = [0 prctile(abs(velocity),95)];
        end

        for f=1:nrFrames
            imagesc(ax,1:nrX,1:nrY,frames(:,:,f));
            hold on
            imagesc(ax,xWindow,yWindow,zoomed(:,:,f));
            
            % Show the zoomed search limits
            line([min(xWindow) min(xWindow) max(xWindow) max(xWindow) min(xWindow) ]',[min(yWindow) max(yWindow) max(yWindow) min(yWindow) min(yWindow)])
            if  pv.track
                switch (pv.type)
                    case 'eye'
                        if ~isnan(x(f))
                            % Show the pupil estimate
                            areaScale=(hFig.Position(3)/nrX).^2;
                            scatter(ax,x(f),y(f),areaScale*a(f),'r');
                            hold off
                        end
                    case 'ball'
                        if ~isnan(velocity(f))
                            history = 30; % Show the lasst 30 frames
                            fToKeep = f-history:f;
                            fToKeep(fToKeep<1) =[];
                            nrF =numel(fToKeep);
                            h = polarplot(axTrack,[complex(zeros(1,nrF)) ;velocity(fToKeep)']);
                            % Use shading such that the most recent frame
                            % is black and earlier ones fade to white.
                            ix = round(linspace(255,1,nrF));
                            colors = gray;
                            colors = num2cell(colors(ix,:),2)';
                            [h.Color] =deal(colors{:});
                        end
                        if ~isnan(quality(f))
                            hold on
                            polarplot(0,0,'.','MarkerSize',10,'Color',[max(0,1-quality(f)) min(1,quality(f)) 0])
                            hold off
                        end
                        % polarplot puts ticks back every time.
                        axTrack.RTickLabel = [];
                        axTrack.ThetaTickLabel  = [];
                        axTrack.RTick = [];
                        axTrack.ThetaTick  = [];
                end
            end
            drawnow
        end
    else % Not tracking just viewing the movie
        for f=1:nrFrames
            imagesc(ax,frames(:,:,f));
            hold on
            % Show the zoomed search limits
            line([min(xWindow) min(xWindow) max(xWindow) max(xWindow) min(xWindow) ]',[min(yWindow) max(yWindow) max(yWindow) min(yWindow) min(yWindow)])
            drawnow
        end
    end
end

%% Prepare output
switch (pv.type)
    case 'eye'
        tracked =struct('x',x,'y',y,'a',a,'quality',quality);
    case 'ball'
        tracked =struct('velocity',velocity,'quality',quality);
end
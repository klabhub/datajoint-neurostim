function [tracked] = movieTracker(in,type, pv)
% Function extract tracking information from movies recorded by ScanBox cameras.
% Currently this can process _eye and _ball movies.
% For _eye it estimates eye position and pupil size
% For _ball it estimates 2D velocity.
%
% in  -  Three options:
%           Filename for a movie file generated by Scanbox
%           struct (.data, .abstime) with contentfrom such a file,
%           a ns.Experiment table row.
% type - eye or ball
%
%
% Optional PV Pairs
%
% manualRoi  - Select the ROI manually by clicking twice on hte average
%               image. The first click gives the center, the second the
%               search radius. [false]
% binarize    -Binarize the images based on the graythresh of 
%               100 randomly drawn frames . [false] 
% nrWorkers - The number of parallel workers to use (eye only). [-1] 
%               -1 = use the ones that are running already.
% Cosmetic
% map - Use this colormap to show the movie
% history - Show the current frame plus the preceding few.
% movie - Show a movie of the results (or just a movie)
% track - Perform tracking.
% startFrame - discard frames before this one [1].
% stopFrame  -discard frames after this one [inf].
%
% Eye algorithm (see imfindcircles):
% minRadius,maxRadius - Possible sizes  (in pixels) of the pupil [12,32]
% searchRadius - Search only this radius (pixels) around the center of the image [100]
% method - PhaseCode or TwoStage ["PhaseCode"]
% sensitivity  - [0.85]
% edgeThreshold - []
%
% OUTPUT
% tracked - A struct
%           .x .y .a and .quality for eye tracking
%           .velocity .quality (correlation between successive frames) for ball tracking
%            Each entry corresponds to a sbx frame recorded during this
%            ns.Experiment,
% Adapted from Dario Ringach' example code
% BK - 3/9/2023
arguments
    in
    type char {mustBeMember(type,{'eye','ball'})} = 'eye'
    pv.nrWorkers = -1
    pv.map = bone
    pv.movie (1,1) logical = false
    pv.track (1,1) {mustBeA(pv.track,{'logical','struct'})} = true

    % Eye movies: PV pairs passed to imfindcircles
    pv.method = "PhaseCode"
    pv.sensitivity  = 0.85;
    pv.edgeThreshold = [];
    pv.minRadius (1,1) double = 10
    pv.maxRadius (1,1) double = 50
    pv.searchRadius  (1,1) double = inf   % From center.

    pv.history = 3; % Show the last n frames
    pv.startFrame = 1;
    pv.stopFrame = inf;
    pv.manualRoi (1,1) logical = false
  
end

%% Get the frames
switch class(in)
    case 'ns.Experiment'        
        % A key representing an experiment
        file = ns.File & in & 'extension=''.mj2''' & ['filename LIKE ''%_'  type '.mj2'''];       
        matFile = fetch1(file,'filename');
        ff = fullfile(folder(in),matFile);
        if ~exist(ff,'file')
            error('Movie file %s not found',ff)
        end
        movie = VideoReader(ff);        
    case {'char','string'}
        % Load from file
        movie = VideoReader(in);
    otherwise
        error('sbx.eyeTracker cannot handle %s inputs',class(in));
end

%% Start parpool if requested
if pv.nrWorkers ==-1
    if isempty(gcp('nocreate'))
        pv.nrWorkers = 0;
    else
        pv.nrWorkers  = gcp('nocreate').NumWorkers;
    end
end

%% Open a figure if requested
if pv.manualRoi || pv.movie
    hFig= findobj(0,'type','figure','name','movieTracker');
    if isempty(hFig)
        hFig =  figure('name','movieTracker');
    end
end

if isinf(pv.stopFrame)
    pv.stopFrame = movie.NumFrames;
end


%% Select an ROI manually or based on the search radius
if pv.manualRoi && ~isstruct(pv.track)
    figure(hFig)
    colormap("gray")
    %imagesc(mean(frames,3,"omitnan"));
    imagesc(movie.readFrame);
    [xLim,yLim] = ginput(2);
    center = [xLim(1) yLim(1)];
    searchRadius = ceil(sqrt(diff(xLim).^2+diff(yLim).^2));
    pv.maxRadius = min(pv.maxRadius,searchRadius);
    range = (-searchRadius:searchRadius);
    xWindow = round(center(1)+range);
    yWindow = round(center(2)+range);
elseif ~isinf(pv.searchRadius)
    xWindow  = round((-pv.searchRadius:pv.searchRadius) + movie.Width/2);
    yWindow  = round((-pv.searchRadius:pv.searchRadius) + movie.Height/2);
else
    xWindow  = 1:movie.Width;
    yWindow  = 1:movie.Height;
end

xWindow(xWindow< 1 | xWindow>movie.Width) =[];
yWindow(yWindow< 1 | yWindow>movie.Height) =[];


%% Run the tracking algorithm
if islogical(pv.track) && pv.track
    %% Initialize output vars
    x       = nan(movie.NumFrames,1);
    y       = nan(movie.NumFrames,1);
    a       = nan(movie.NumFrames,1);
    velocity = nan(movie.NumFrames,1);
    quality  = nan(movie.NumFrames,1);

            
    switch type
        case 'eye'
    
            fprintf('Eye tracking analysis on %d workers\n',pv.nrWorkers)
            parfor (f=pv.startFrame:pv.stopFrame,pv.nrWorkers)
            %for f=1:movie.NumFrames  % debug
                frame  = movie.read(f);
                frame = frame(xWindow,yWindow);   
                [center,radius,thisQuality] = imfindcircles(single(frame),[pv.minRadius searchRadius],'Method',pv.method,'Sensitivity',pv.sensitivity,'EdgeThreshold',pv.edgeThreshold); %#ok<PFBNS>
                if ~isempty(center)
                    [~,idx] = max(thisQuality); % pick the circle with best score
                    x(f) = xWindow(1) + center(idx,1);
                    y(f) = yWindow(1) + center(idx,2);
                    a(f) = pi*radius(idx)^2;
                end
            end
        case 'ball'
            % Determine successive image shifts by maximizing the
            % cross correlation.

            % Although this could use a parfor, that does not provide much
            % of an advantage (if any). Probably because xcorr already uses
            % multithreading. I also tried imregtform and normxcorr2 but
            % saw worse performance.
            for f=(pv.startFrame+1):pv.stopFrame
                frames = movie.read([f-1 f]);
                z1= frames(yWindow,xWindow,1);
                z2= frames(yWindow,xWindow,2);
                z1 = z1 -mean(z1,"all");
                z2 = z2 -mean(z2,"all");
                xc =xcorr2(z1,z2);
                [maxXC,ix] = max(xc(:));
                quality(f) = maxXC./max(xcorr2((z2+z1)/2,(z2+z1)/2),[],"all");
                [dy,dx]= ind2sub(size(xc),ix);
                dy = dy-size(z2,1);
                dx = dx-size(z2,2);
                velocity(f) = dx  + 1i.*dy;
            end
    end
elseif isstruct(pv.track)
    % User passed a previously computed track to show the movie.
    quality = pv.track.quality;
    switch (type)
        case 'eye'
            x =pv.track.x;
            y = pv.track.y;
            a = pv.track.a;
        case 'ball'
            velocity = pv.track.velocity;
    end
    pv.track =true;
end

%% Show a movie
if pv.movie
    % Show it
    figure(hFig);
    ax = axes('Position',[0 0 1 1]);
    colormap(ax,pv.map)
    axis(ax,'off')
    if pv.track
        switch (type)
            case 'eye'
            case 'ball'
                % Show the tracked velocity in the lower left corner
                pos = get(ax,'Position');
                axPolar = polaraxes(hFig,'Position',[0 0 pos(3:4)/5]);
                axSpeed = axes(hFig,'Position',[0.75 0.05 pos(3:4)/5]);
        end

        for f=pv.startFrame:pv.stopFrame
            hold off
            imagesc(ax,1:movie.Width,1:movie.Height,movie.read(f));
            hold on
            % Show the zoomed search limits
            line(ax,[min(xWindow) min(xWindow) max(xWindow) max(xWindow) min(xWindow) ]',[min(yWindow) max(yWindow) max(yWindow) min(yWindow) min(yWindow)])
            if  pv.track
                switch (type)
                    case 'eye'
                        if ~isnan(x(f))
                            % Show the pupil estimate
                            areaScale=(hFig.Position(3)/movie.Width).^2;
                            scatter(ax,x(f),y(f),areaScale*a(f),'r');
                            hold off
                        end
                    case 'ball'
                        if ~isnan(velocity(f))
                            fToKeep = f-pv.history:f;
                            fToKeep(fToKeep<1) =[];
                            nrF =numel(fToKeep);
                            h = polarplot(axPolar,[complex(zeros(1,nrF)) ;velocity(fToKeep)']);
                            % Use shading such that the most recent frame
                            % is black and earlier ones fade to white.
                            ix = round(linspace(255,1,nrF));
                            colors = gray;
                            colors = num2cell(colors(ix,:),2)';
                            [h.Color] =deal(colors{:});
                            maxVelocity = max(eps,prctile(abs(velocity),95));
                            axPolar.RLim = [0 maxVelocity];

                            %% speed
                            nrFramesToKeep= 100;
                            fToKeep = f+(-nrFramesToKeep:0);
                            fToKeep(fToKeep<1)=[];
                            plot(axSpeed,fToKeep,abs(velocity(fToKeep)),'r');
                            xlim(axSpeed,[f-nrFramesToKeep f])
                            ylim(axSpeed,[0 maxVelocity]);
                            set(axSpeed,'YTick',[])
                        end

                        if ~isnan(quality(f))
                            hold(axPolar,"on")
                            polarplot(axPolar,0,0,'.','MarkerSize',10,'Color',[max(0,1-quality(f)) min(1,quality(f)) 0])
                            hold(axPolar,"off")
                        end
                        % polarplot puts ticks back every time.
                        axPolar.RTickLabel = [];
                        axPolar.ThetaTickLabel  = [];
                        axPolar.RTick = [];
                        axPolar.ThetaTick  = [];
                end
            end
            drawnow
        end
    else % Not tracking just viewing the movie
        for f=pv.startFrame:pv.stopFrame
            imagesc(ax,movie.read(f));
            hold on
            % Show the zoomed search limits
            line([min(xWindow) min(xWindow) max(xWindow) max(xWindow) min(xWindow) ]',[min(yWindow) max(yWindow) max(yWindow) min(yWindow) min(yWindow)])
            drawnow
        end
    end
end

%% Prepare output
switch (type)
    case 'eye'
        tracked =struct('x',x,'y',y,'a',a,'quality',quality);
    case 'ball'
        tracked =struct('velocity',velocity,'quality',quality);
end